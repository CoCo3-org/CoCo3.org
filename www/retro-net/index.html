<!doctype html>
<html>
<head>
	<title>CoCo3.org -- Retro.NET</title>
	<style type="text/css"> 
		body { font-family:tahoma,arial,helvetica; font-size:14px; }
		h1 { font-weight:bold; font-size:16px; }
		h2 { font-weight:bold; font-size:14px; }
		div#navbar { height:26px; border-top:solid #000 1px; border-bottom:solid #000 1px; }
		div#navbar ul {	margin:0px; padding:0px; font-weight:bold; line-height:26px; white-space:nowrap; text-align:center; }
		div#navbar li {	list-style-type:none; display:inline; color:#B8B8B8; }
		div#navbar li a { text-decoration:none; padding:8px; }
		div#navbar li a:link { color:#808080; }
		div#navbar li a:visited { color:#808080; }
		div#navbar li a:hover { color:#FFFFFF; background-color:#C0C0C0; }
	</style>
</head>
<body>
	<form id="form1">
		<div style="padding:20px; width:800px;">
			
			<a href="http://www.6809.org.uk/twilight/sock/">
				<img style="margin:10px; float:left;" src="../images/coco6.gif" width="179" height="96" alt="" />
			</a>
			
			<div id="navbar">
				<ul>
					<li><a href="../index.html">Home</a></li>
					<li><a href="../blog.html">Blog</a></li>
					<li><a href="../projects.html">Projects</a></li>
					<li><a href="../links.html">Links</a></li>
					<li><a href="../about.html">About</a></li>
				</ul>
			</div>

			<div style="width:220px;margin:5px;padding:0px 10px 0px 10px;float:right;border-style:dotted;border-color:blue;">
				<p><strong><a href="https://github.com/CoCo3-org/Retro.NET">GitHub</a></strong> / <strong><a href="https://github.com/CoCo3-org/Retro.NET/commits/master">commits</a></strong></p>

				<p>My plan (and hope) is to have a <strong>Version 1.0</strong> release ready for the next <strong>CoCo Fest 2023</strong>.  It would be cool if I could make it, but this far out not sure I will be able to.  Perhaps by January 2023 I will know if I can make it or not and make plans accordingly.</p>
			</div>

			<p>7/14/2022 10:00 PM: – I am still looking over some open source CPU emulators.  There are a many!  I’ll get there.</p>  
			
			<p>In the mean time I am going to take the approach that for each target CPU code generation I need <strong>a class for each and every opcode / instruction</strong>.  Instead of creating a plain text file w/ the assembly language in it.  In essence each line will be an instruction class instance of that very opcode.  I feel like with that extra layer of structure I will be able to do things and keep track of stuff more efficiently.  I mean where do you put the code for tracking each register being used, etc … also, it might be possible to create a second or more passes just at the assembly opcode/instruction level to optimize the generated code.  We will see if that works out.  I am generating all the instruction / opcode classes instead of creating them manually.</p>

			<hr id="B4" />

			<p>7/4/2022 6:35 PM: – I can’t help but add an <strong>emulation layer</strong> for each of the <strong>CPU</strong>’s that Retro.NET will target. That is a lot of work, but I believe that in the long run it will save me time.</p>  
			
			<p>Here’s why; it’s not easy testing the code that is generated.  It’s not easy to do it manually, let alone in automated tests. You have to load an emulator, then you have to load the program you have generated, then you have to run the program and finally you have to compare the results with what you were expecting. That is a drawn out process to do it manually, you will spend a lot of time doing just that. To do that using automated integration testing on multiple emulators is virtually impossible. I’d rather create an emulation layer that is integrated and then all the testing can be automated. Then we can add whatever custom tools we need in the emulation like cycle counting and profiling, etc…</p>

			<p>So decision made, I will be adding an emulator to each of the CPU targets.</p>

			<hr id="B3" />

			<p>7/3/2022 2:20 AM: – We need to <strong>locate our tools</strong>: I am going w/ the latest and greatest Visual Studio 2022 Community Edition.</p>
			
			<p>On my computer:</p> 
			
			<p>The C# command line compiler is at<br/> 
			<code>"C:\Program Files\Microsoft Visual Studio\2022\Community\Msbuild\Current\Bin\Roslyn\csc.exe"</code>
			<br/><br/>
			The ILDASM is at<br/> 
			<code>"C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.8 Tools\ildasm.exe"</code> 
			<br/><br/>
			The ILASM was found at<br/> 
			<code>"C:\Windows\Microsoft.NET\Framework\v4.0.30319\ilasm.exe"</code></p>

			<p>Now we make environment variables out of them: note the quotes around the two paths that have spaces in them!</p>

			<img src="Images/environment.png" width="737" height="210" border="0" alt="">

			<p>Now when we want to run these from the command line or in a script we can just use the environment variable name.</p>

			<code>
			C:\Jar>%VS_CSC% /?<br/>
			Microsoft (R) Visual C# Compiler version 4.2.0-4.22252.24 (47cdc16a)<br/>
			Copyright (C) Microsoft Corporation. All rights reserved.<br/>
			<br/>
			C:\Jar>%VS_ILDASM% /?<br/>
			Microsoft (R) .NET Framework IL Disassembler.  Version 4.8.3928.0<br/>
			Copyright (c) Microsoft Corporation.  All rights reserved.<br/>
			<br/>
			C:\Jar>%VS_ILASM% /?<br/>
			Microsoft (R) .NET Framework IL Assembler version 4.8.4161.0<br/>
			Copyright (c) Microsoft Corporation.  All rights reserved.<br/>
			</code>

			<p>Alternately, we could put those paths in our system PATH environment variable.</p>

			<hr id="B2" />

			<p>7/2/2022 8:30 PM: – <strong>The Plan</strong></p>

			<p>Starting w/ “Hello World” systematically make all parts work for each target.</p>

			<p>At first concentrate on 4 target systems…  later we will add more.</p>

			<ul>
				<li><strong>Interpreter Target</strong>.  This is our own .NET Engine written in C#.  It is for our own understanding of how the IL byte codes work. If we are able to interpret them then we should be able to write assembly code that does the same thing in the target CPU’s.  In the end the interpreter could also possibly be used as an interactive development tool if we implement the retro libraries and emulate those systems. The interpreter will not be written for efficiency, but for documenting how the byte codes are supposed to work.</li>
				<li><strong>The 6x09 Target</strong> (CoCo1&2,3)</li>
				<li><strong>The 6803 Target</strong> (MC-10)</li>
				<li><strong>The Z80 Target</strong> (MSX)</li>
			</ul>

			<p>Then we build on Hello World code and keep adding more and more functionality which will add more IL byte codes that we need to implement in all four targets above.

			<hr id="B1" />

			<p>6/15/2022 – <strong>Retro.NET</strong></p>

			<p>The goal is to create an Ahead-of-Time (AoT) compiler for the .NET byte code <strong><a href="https://en.wikipedia.org/wiki/Common_Intermediate_Language">Common Intermediate Language</a></strong> (CIL) (formerly called MSIL) for retro 8 and 16 bit CPU’s.  It’s a lofty goal, but to keep it simple we are not going to be using ANY of the .NET libraries other than a subset of the Console library.  Therefore a person will not be able to just grab any source code or .NET executable and compile it for a retro computer.  Instead I plan on having separate libraries that are optimized for the old 8 & 16 bit computers.</p>

			<p>You will be able to create programs written in C# for your old computer using one of Microsoft <strong><a href="https://visualstudio.microsoft.com/">Visual Studio</a></strong> versions. You should be able to use any version. It should be pretty neat.</p>

			<p>I’ve made the GitHub <strong><a href="https://github.com/CoCo3-org/Retro.NET">repo</a></strong> for the project public and will be developing in the open. Hopefully that will make me stick with it and help me make regular progress.</p>

		</div>
	</form>
</body>
</html>
