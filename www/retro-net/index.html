<!doctype html>
<html>
<head>
	<title>CoCo3.org -- Retro.NET</title>
	<style type="text/css">
		body { font-family:tahoma,arial,helvetica; font-size:14px; color:#FFFFFF;  background-color:#303030; }
		h1 { font-weight:bold; font-size:16px; }
		h2 { font-weight:bold; font-size:14px; }
		a:link    { color: #DFDF00; }
		a:visited { color: #DFDF00; }
		a:hover   { color: #888800; }
		a:active  { color: #FFFF00;	}
		div#navbar { height:26px; border-top:solid #000 1px; border-bottom:solid #000 1px; }
		div#navbar ul { margin:0px; padding:0px; font-weight:bold; line-height:26px; white-space:nowrap; text-align:center; }
		div#navbar li { list-style-type:none; display:inline; color:#B8B8B8; }
		div#navbar li a { text-decoration:none; padding:8px; }
		div#navbar li a:link { color:#808080; }
		div#navbar li a:visited { color:#808080; }
		div#navbar li a:hover { color:#FFFFFF; background-color:#C0C0C0; }
	</style>
</head>
<body>
	<form id="form1">
		<div style="padding:20px; width:800px;">
			
			<a href="http://www.6809.org.uk/twilight/sock/">
				<img style="margin:10px; float:left;" src="../images/coco6.gif" width="179" height="96" alt="" />
			</a>
			
			<div id="navbar">
				<ul>
					<li><a href="../index.html">Home</a></li>
					<li><a href="../blog.html">Blog</a></li>
					<li><a href="../projects.html">Projects</a></li>
					<li><a href="../links.html">Links</a></li>
					<li><a href="../about.html">About</a></li>
				</ul>
			</div>

			<div style="width:220px;margin:5px;padding:0px 10px 0px 10px;float:right;border-style:dotted;border-color:blue;">
				<p><strong><a href="https://github.com/CoCo3-org/Retro.NET">GitHub</a></strong> / <strong><a href="https://github.com/CoCo3-org/Retro.NET/commits/master">commits</a></strong></p>
				<p>Originally I wanted something for this years CoCoFEST 2023 -- but that is just not going to happen. I hope to have a <strong>Version 1.0</strong> release ready for <strong>CoCoFest 2024</strong>. Perhaps by then I can actually go to CoCoFEST. It's definetly on my bucket list!</p>
			</div>

			<p>2/27/2023 4:00 PM: - <i style="color: lightblue;">Change of plans again:</i> removed <strong>Retro.IDE</strong> and will concetrate solely on this compiler project until I have at least a version 0.1 or higher!</p>

			<hr id="B9" />

			<s><p>12/11/2022 10:25 PM: - This project is replaced by <strong>Retro.IDE</strong></p></s>

			<hr id="B8" />
			<s>
			<p>12/11/2022 8:00 PM: - For almost 3 months I've been waffling back-and-forth on how to proceed.  As it sits, there is too much code that is not unit-tested to get everything working.</p>
			<p>So, indeed <strong>I actually need to start over.</strong></p>
			<p>I need to start over and bring over the code piece by piece using Test Driven Development (TDD).  And get every piece working properly before moving on to the next piece. This will be my acid test of TDD to see if it works and if it's worth it.</p>
			<p>Therefore all future development on Retro.NET will take place in the Retro.IDE project.  At some point  I may break-out Retro.NET from Retro.IDE and make it a stand-alone project.  Until then it will be a sub-project of Retro.IDE.</p>
			<p>It may look like I am jumping from the pot into the fire, since Retro.IDE is going to be a massively larger project.  But after much thought, I want to create these compilers and these tools and they will all share much of the root code.  Therefore I will work on them ALL at the same time -- unit-test by unit test.</p>
			<p>How do you eat an elephant? One bite at a time!</p>
			</s>
			<hr id="B7" />

			<s><p>9/22/2022 5:30 PM: - I am going to put a <strong>temporary hold on this project</strong>: Just <strike>for a few weeks</strike> while I figure out some things and make some decisions:  Hint - I need to restart the project and migrate the old code over in a methodical fashion while using Test Driven Development (TDD) to drive the progress, direction, and design.</p></s>

			<p>*Edit* 9/25/2022 4:25 AM: - <i style="color:pink">hmm... NO, this is what I do. When it gets tough I want to start over. Or try a different direction (I.e. move the project to Python).  This is a bad habit I need to break! Starting over is (almost) NEVER the solution!!</i></font></p>

			<p>What happened is that I took code from four different projects that I had written quite some time back, up to 2 or 3 years ago, and I put them together as the starting point for the Retro.NET project.  I do  want to use that code but I needed to bring the code together piece by piece through the process of Unit Testing and get each piece working before moving on to the next.  And using the TDD principles I'll be able to refactor and restructure and ensure everything is working properly as I develop and make progress.</p>
			
			<p>*Edit* 9/25/2022 4:35 AM: - <i style="color:pink">That is true; I brought several old projects together and the code is in a bit of a mess... Well -- OK, a lot of a mess. Still, starting over is not the answer. I need to get used to the idea that it is possible to take old code and begin using Unit Testing and TDD principles to fix the code and make it work. And to reorganize and refactor the code.</i></p>

			<hr id="B6" />

			<p>7/14/2022 10:00 PM: - I am still looking over some open source CPU emulators.  There are a many!  I'll get there.</p>  
			
			<p>In the mean time I am going to take the approach that for each target CPU code generation I need <strong>a class for each and every opcode / instruction</strong>.  Instead of creating a plain text file w/ the assembly language in it.  In essence each line will be an instruction class instance of that very opcode.  I feel like with that extra layer of structure I will be able to do things and keep track of stuff more efficiently.  I mean where do you put the code for tracking each register being used, etc - also, it might be possible to create a second or more passes just at the assembly opcode/instruction level to optimize the generated code.  We will see if that works out.  I am generating all the instruction / opcode classes instead of creating them manually.</p>

			<hr id="B5" />

			<p>7/7/2022 6:50 AM: - There has been an absolute explosion of CPU emulators written in the last few years. I am searching through <strong>open source CPU emulators</strong> to see what is available that might be a good fit for what I need, which primarily means written in C#. Secondarily it needs to be straight-forward and easy to re-use / integrate. I've already located 10 possibilities just for the Z80. One that stands out is: <strong><a href="https://github.com/MoleskiCoder/EightBitNet">Collection of eight-bit processor emulators</a></strong> (for various projects). Not only is the 6809 one of the CPUs there's also the Z80, M6502 & i8080. Looks promising. I will research the others I came across as well for more insight, and possibly better fit.</p>

			<hr id="B4" />

			<p>7/4/2022 6:35 PM: - I can't help but add an <strong>emulation layer</strong> for each of the <strong>CPU</strong>s that Retro.NET will target. That is a lot of work, but I believe that in the long run it will save me time.</p>  
			
			<p>Here's why; it's not easy testing the code that is generated.  It's not easy to do it manually, let alone in automated tests. You have to load an emulator, then you have to load the program you have generated, then you have to run the program and finally you have to compare the results with what you were expecting. That is a drawn out process to do it manually, you will spend a lot of time doing just that. To do that using automated integration testing on multiple emulators is virtually impossible. I'd rather create an emulation layer that is integrated and then all the testing can be automated. Then we can add whatever custom tools we need in the emulation like cycle counting and profiling, etc.</p>

			<p>So decision made, I will be adding an emulator to each of the CPU targets.</p>

			<hr id="B3" />

			<p>7/3/2022 2:20 AM: - We need to <strong>locate our tools</strong>: I am going w/ the latest and greatest Visual Studio 2022 Community Edition.</p>
			
			<p>On my computer:</p> 
			
			<p>The C# command line compiler is at<br/> 
			<code>"C:\Program Files\Microsoft Visual Studio\2022\Community\Msbuild\Current\Bin\Roslyn\csc.exe"</code>
			<br/><br/>
			The ILDASM is at<br/> 
			<code>"C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.8 Tools\ildasm.exe"</code> 
			<br/><br/>
			The ILASM was found at<br/> 
			<code>"C:\Windows\Microsoft.NET\Framework\v4.0.30319\ilasm.exe"</code></p>

			<p>Now we make environment variables out of them: note the quotes around the two paths that have spaces in them!</p>

			<img src="Images/environment.png" width="737" height="210" border="0" alt="">

			<p>Now when we want to run these from the command line or in a script we can just use the environment variable name.</p>

			<code>
			C:\Jar>%VS_CSC% /?<br/>
			Microsoft (R) Visual C# Compiler version 4.2.0-4.22252.24 (47cdc16a)<br/>
			Copyright (C) Microsoft Corporation. All rights reserved.<br/>
			<br/>
			C:\Jar>%VS_ILDASM% /?<br/>
			Microsoft (R) .NET Framework IL Disassembler.  Version 4.8.3928.0<br/>
			Copyright (c) Microsoft Corporation.  All rights reserved.<br/>
			<br/>
			C:\Jar>%VS_ILASM% /?<br/>
			Microsoft (R) .NET Framework IL Assembler version 4.8.4161.0<br/>
			Copyright (c) Microsoft Corporation.  All rights reserved.<br/>
			</code>

			<p>Alternately, we could put those paths in our system PATH environment variable.</p>

			<hr id="B2" />

			<p>7/2/2022 8:30 PM: - <strong>The Plan</strong></p>

			<p>Starting w/ -Hello World- systematically make all parts work for each target.</p>

			<p>At first concentrate on 4 target systems - later we will add more.</p>

			<ul>
				<li><strong>Interpreter Target</strong>.  This is our own .NET Engine written in C#.  It is for our own understanding of how the IL byte codes work. If we are able to interpret them then we should be able to write assembly code that does the same thing in the target CPUs.  In the end the interpreter could also possibly be used as an interactive development tool if we implement the retro libraries and emulate those systems. The interpreter will not be written for efficiency, but for documenting how the byte codes are supposed to work.</li>
				<li><strong>The 6x09 Target</strong> (CoCo1&2,3)</li>
				<li><strong>The 6803 Target</strong> (MC-10)</li>
				<li><strong>The Z80 Target</strong> (MSX)</li>
			</ul>

			<p>Then we build on Hello World code and keep adding more and more functionality which will add more IL byte codes that we need to implement in all four targets above.

			<hr id="B1" />

			<p>6/15/2022 - <strong>Retro.NET</strong></p>

			<p>The goal is to create an Ahead-of-Time (AoT) compiler for the .NET byte code <strong><a href="https://en.wikipedia.org/wiki/Common_Intermediate_Language">Common Intermediate Language</a></strong> (CIL) (formerly called MSIL) for retro 8 and 16 bit CPUs.  It's a lofty goal, but to keep it simple we are not going to be using ANY of the .NET libraries other than a subset of the Console library.  Therefore a person will not be able to just grab any source code or .NET executable and compile it for a retro computer.  Instead I plan on having separate libraries that are optimized for the old 8 & 16 bit computers.</p>

			<p>You will be able to create programs written in C# for your old computer using one of Microsoft <strong><a href="https://visualstudio.microsoft.com/">Visual Studio</a></strong> versions. You should be able to use any version. It should be pretty neat.</p>

			<p>I've made the GitHub <strong><a href="https://github.com/CoCo3-org/Retro.NET">repo</a></strong> for the project public and will be developing in the open. Hopefully that will make me stick with it and help me make regular progress.</p>

		</div>
	</form>
</body>
</html>
